function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["assets/solanaProvider.esm-BZxVVR9W.js","assets/index-ClxLoTQ8.js","assets/index-DPwaSrce.css","assets/baseProvider.esm-Dfs2wrmC.js","assets/util-DA1nCe8j.js","assets/nacl-fast-DDtGVY0A.js","assets/ethereumProvider.esm-D3-blcIG.js","assets/browser-kN2ntKGf.js","assets/openloginEd25519.esm-EN_IQ9a1.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
import{aD as N,aE as P,ag as w,au as y,Y as a,ab as u,ac as A,ae as T,af as r,ad as c,ah as g,aj as h,aF as m,aG as R,ai as p,al as d,aH as E,aI as v,a9 as _}from"./index-ClxLoTQ8.js";import{d as D}from"./baseProvider.esm-Dfs2wrmC.js";import"./util-DA1nCe8j.js";const C=(s,i)=>({adapterSettings:{network:N.MAINNET,clientId:"",uxMode:P.POPUP},chainConfig:s?w(s,i):null,loginSettings:{}});function O(s,i){var n=Object.keys(s);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(s);i&&(e=e.filter(function(o){return Object.getOwnPropertyDescriptor(s,o).enumerable})),n.push.apply(n,e)}return n}function t(s){for(var i=1;i<arguments.length;i++){var n=arguments[i]!=null?arguments[i]:{};i%2?O(Object(n),!0).forEach(function(e){a(s,e,n[e])}):Object.getOwnPropertyDescriptors?Object.defineProperties(s,Object.getOwnPropertyDescriptors(n)):O(Object(n)).forEach(function(e){Object.defineProperty(s,e,Object.getOwnPropertyDescriptor(n,e))})}return s}class L extends y{constructor(i){var n,e,o;super(),a(this,"name",u.OPENLOGIN),a(this,"adapterNamespace",A.MULTICHAIN),a(this,"type",T.IN_APP),a(this,"openloginInstance",null),a(this,"status",r.NOT_READY),a(this,"currentChainNamespace",c.EIP155),a(this,"openloginOptions",void 0),a(this,"loginSettings",{}),a(this,"privKeyProvider",null),g.debug("const openlogin adapter",i);const l=C((n=i.chainConfig)===null||n===void 0?void 0:n.chainNamespace,(e=i.chainConfig)===null||e===void 0?void 0:e.chainId);if(this.openloginOptions=t(t({clientId:"",network:N.MAINNET},l.adapterSettings),i.adapterSettings||{}),this.loginSettings=t(t({},l.loginSettings),i.loginSettings),this.sessionTime=this.loginSettings.sessionTime||86400,(o=i.chainConfig)!==null&&o!==void 0&&o.chainNamespace){var f;this.currentChainNamespace=(f=i.chainConfig)===null||f===void 0?void 0:f.chainNamespace;const I=l.chainConfig?l.chainConfig:{};if(this.chainConfig=t(t({},I),i==null?void 0:i.chainConfig),g.debug("const openlogin chainConfig",this.chainConfig),!this.chainConfig.rpcTarget&&i.chainConfig.chainNamespace!==c.OTHER)throw h.invalidParams("rpcTarget is required in chainConfig")}}get chainConfigProxy(){return this.chainConfig?t({},this.chainConfig):null}get provider(){var i;return((i=this.privKeyProvider)===null||i===void 0?void 0:i.provider)||null}set provider(i){throw new Error("Not implemented")}async init(i){var n;if(super.checkInitializationRequirements(),!((n=this.openloginOptions)!==null&&n!==void 0&&n.clientId))throw h.invalidParams("clientId is required before openlogin's initialization");if(!this.chainConfig)throw h.invalidParams("chainConfig is required before initialization");let e=!1;if(this.openloginOptions.uxMode===P.REDIRECT){const o=m();Object.keys(o).length>0&&o._pid&&(e=!0)}this.openloginOptions=t(t({},this.openloginOptions),{},{replaceUrlOnRedirect:e}),this.openloginInstance=new R(this.openloginOptions),g.debug("initializing openlogin adapter init"),await this.openloginInstance.init(),this.status=r.READY,this.emit(p.READY,u.OPENLOGIN);try{g.debug("initializing openlogin adapter"),this.openloginInstance.privKey&&(i.autoConnect||e)&&await this.connect()}catch(o){g.error("Failed to connect with cached openlogin provider",o),this.emit("ERRORED",o)}}async connect(i){super.checkConnectionRequirements(),this.status=r.CONNECTING,this.emit(p.CONNECTING,t(t({},i),{},{adapter:u.OPENLOGIN}));try{return await this.connectWithProvider(i),this.provider}catch(n){throw g.error("Failed to connect with openlogin provider",n),this.status=r.READY,this.emit(p.ERRORED,n),n!=null&&n.message.includes("user closed popup")?d.popupClosed():d.connectionError("Failed to login with openlogin")}}async disconnect(){let i=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{cleanup:!1};if(this.status!==r.CONNECTED)throw d.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw h.notReady("openloginInstance is not ready");await this.openloginInstance.logout(),i.cleanup?(this.status=r.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=r.READY,this.emit(p.DISCONNECTED)}async authenticateUser(){if(this.status!==r.CONNECTED)throw d.notConnectedError("Not connected with wallet, Please login/connect first");return{idToken:(await this.getUserInfo()).idToken}}async getUserInfo(){if(this.status!==r.CONNECTED)throw d.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw h.notReady("openloginInstance is not ready");return await this.openloginInstance.getUserInfo()}setAdapterSettings(i){if(this.status===r.READY)return;const n=C();this.openloginOptions=t(t(t({},n.adapterSettings),this.openloginOptions||{}),i),i.sessionTime&&(this.loginSettings=t(t({},this.loginSettings),{},{sessionTime:i.sessionTime}))}setChainConfig(i){super.setChainConfig(i),this.currentChainNamespace=i.chainNamespace}async connectWithProvider(i){if(!this.chainConfig)throw h.invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw h.notReady("openloginInstance is not ready");if(this.currentChainNamespace===c.SOLANA){const{SolanaPrivateKeyProvider:o}=await E(()=>import("./solanaProvider.esm-BZxVVR9W.js").then(l=>l.s),__vite__mapDeps([0,1,2,3,4,5]));this.privKeyProvider=new o({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===c.EIP155){const{EthereumPrivateKeyProvider:o}=await E(()=>import("./ethereumProvider.esm-D3-blcIG.js"),__vite__mapDeps([6,1,2,3,4,7]));this.privKeyProvider=new o({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===c.OTHER)this.privKeyProvider=new D;else throw new Error("Invalid chainNamespace: ".concat(this.currentChainNamespace," found while connecting to wallet"));if(!this.openloginInstance.privKey&&i){var n;this.loginSettings.curve||(this.loginSettings.curve=this.currentChainNamespace===c.SOLANA?v.ED25519:v.SECP256K1),await this.openloginInstance.login(_(this.loginSettings,{loginProvider:i.loginProvider},{extraLoginOptions:t(t({},i.extraLoginOptions||{}),{},{login_hint:i.login_hint||((n=i.extraLoginOptions)===null||n===void 0?void 0:n.login_hint)})}))}let e=this.openloginInstance.privKey;if(e){if(this.currentChainNamespace===c.SOLANA){const{getED25519Key:o}=await E(()=>import("./openloginEd25519.esm-EN_IQ9a1.js"),__vite__mapDeps([8,5,1,2]));e=o(e).sk.toString("hex")}await this.privKeyProvider.setupProvider(e),this.status=r.CONNECTED,this.emit(p.CONNECTED,{adapter:u.OPENLOGIN,reconnected:!i})}}}export{L as OpenloginAdapter,C as getOpenloginDefaultOptions};
